
group Haxe;
emit(data) ::= "<data>"
module(mod, imp, decs, beg) ::= <<
<imp>
class <mod> {
  <decs>
  <beg>
}
>>
ident(name) ::= "<name>"
pass() ::= ""
begin(block) ::= <<
  public static function main() {
     <block>
  }
>>
block(stmts) ::= <<
<stmts; separator=";\n">;
>>
import_stmt(mods) ::= <<
import <mods; separator=", ">;
>>
invoke(obj, args) ::= <<
<obj><if (args)>( <args> )<else>( )<endif>
>>

args(args) ::= <<
<args; separator=", ">
>>
qualident(mod, ident) ::= "<mod>.<ident>"
literal_str(str) ::= "<str>"
literal_int(int) ::= "<int>"
negative(expr) ::= "-<expr>"
positive(expr) ::= "+<expr>"
inverted(expr) ::= "!<expr>"
op_add(a, b) ::= "<a> + <b>"
op_sub(a, b) ::= "<a> - <b>"
op_mul(a, b) ::= "<a> * <b>"
op_div(a, b) ::= "Std.int( <a> / <b> )"
op_mod(a, b) ::= "<a> % <b>"
grouped(expr) ::= "( <expr> )"
consts(consts) ::= "<consts>"
declare_const(name, value) ::= <<
static inline var <name> = <value>;

>>
declare(type, names, sym) ::= <<
<names:{n|var <n>:<type>;}; separator="\n">
>>
vars(vars) ::= <<
  <vars; separator="\n">
>>
assign(obj, expr) ::= "<obj> = <expr>"
array_type(dims, of_type) ::= <<
Array\<<of_type>\>
>>
consts(consts) ::= <<
<consts; separator="\n">
>>
